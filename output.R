# (C) 2008-2016 Potsdam Institute for Climate Impact Research (PIK),
# authors, and contributors see AUTHORS file
# This file is part of MAgPIE and licensed under GNU AGPL Version 3 
# or later. See LICENSE file or go to http://www.gnu.org/licenses/
# Contact: magpie@pik-potsdam.de

##########################################################
#### MAgPIE output generation ####
##########################################################
# Version 2.2, Florian Humpenoeder, Jan Philipp Dietrich, Misko Stevanovic
# Type "Rscript output.R" to start the script in the command line

# Version 1.1: added output module selection, reporting.gms is now generated by R script (fh)
# Version 1.2: general code checking (jpd)
# Version 1.3: added postprocessing (fh)
# Version 1.4: renamed from reporting.R to output.R (fh)
# Version 1.5: modified source_include (FH)
# Version 1.6: renamed config_file to config (jpd)
# Version 1.7: Added R output scripts to choice of output modules (fh)
# Version 1.7: Can now execute validation (MB)
# Version 1.8: Bugfix: unused connections are now closed (jpd)
# Version 1.9: Added option to execute output scripts over all output folders (FH)
# Version 2.0: removed GAMS output, standardized R script output (jpd)
# Version 2.1: added option to execute R output scripts across magpie runs (FH)
# Version 2.2: added function get_line() to read line from the terminal or from a connection;
#							 added the option to choose folders based on a pattern search or 
#							 the regular expression	(MS)
#########################################################################################

#load landuse library
library(lucode)

#debug mode
debug <- FALSE

###Define arguments that can be read from command line
if(!exists("source_include")) {
  readArgs("outputdir","output","comp","remind_dir")
}

on_new_cluster <- file.exists('/p/projects/landuse')
on_old_cluster <- file.exists('/iplex/01/landuse') & !on_new_cluster

#Setting relevant paths
if(on_old_cluster) { #run is performed on the old cluster
  pythonpath <- '/iplex/01/landuse/bin/python/bin/'
  latexpath  <- '/iplex/01/sys/applications/texlive/bin/x86_64-linux/'  
  gamspath   <- '/iplex/01/sys/applications/gams/'
} else {
  pythonpath <- ''
  latexpath  <- ''
  gamspath   <- ''
}

get_line <- function(){
	# gets characters (line) from the terminal of from a connection
	# and stores it in the return object
	if(interactive()){
		s <- readline()
	} else {
		con <- file("stdin")
		s <- readLines(con, 1, warn=FALSE)
		on.exit(close(con))
	}
	return(s);
}

choose_folder <- function(folder,title="Please choose a folder") {
  tmp <- base::list.dirs(folder,recursive=TRUE)
  dirs <- NULL
  for (i in 1:length(tmp)) {
    if (file.exists(path(tmp[i],"full.gms"))) dirs <- c(dirs,sub("./output/","",tmp[i]))
  }
  dirs <- c("all",dirs)
  cat("\n\n",title,":\n\n")
  cat(paste(1:length(dirs), dirs, sep=": " ),sep="\n")
	cat(paste(length(dirs)+1, "Search by the pattern.\n", sep=": "))
  cat("\nNumber: ")
	identifier <- get_line()
  identifier <- strsplit(identifier,",")[[1]]
  tmp <- NULL
  for (i in 1:length(identifier)) {
    if (length(strsplit(identifier,":")[[i]]) > 1) tmp <- c(tmp,as.numeric(strsplit(identifier,":")[[i]])[1]:as.numeric(strsplit(identifier,":")[[i]])[2])
    else tmp <- c(tmp,as.numeric(identifier[i]))
  }
  identifier <- tmp
  # PATTERN
	if(length(identifier==1) && identifier==(length(dirs)+1)){
		cat("\nInsert the search pattern or the regular expression: ")
		pattern <- get_line()
		id <- grep(pattern=pattern, dirs[-1])
		# lists all chosen directories and ask for the confirmation of the made choice
		cat("\n\nYou have chosen the following directories:\n")
		cat(paste(1:length(id), dirs[id+1], sep=": "), sep="\n")
		cat("\nAre you sure these are the right directories?(y/n): ")
		answer <- get_line()
		if(answer=="y"){
			return(dirs[id+1])
		} else choose_folder(folder,title)
	# 
	} else if(any(dirs[identifier] == "all")){
		identifier <- 2:length(dirs)
		return(dirs[identifier])
	} else return(dirs[identifier])
}


choose_module <- function(Rfolder,title="Please choose an outputmodule") {
  module <- gsub("\\.R$","",grep("\\.R$",list.files(Rfolder), value=TRUE))
  cat("\n\n",title,":\n\n")
  cat(paste(1: length(module), module, sep=": " ),sep="\n")
  cat("\nNumber: ")
  identifier <- get_line()
  identifier <- as.numeric(strsplit(identifier,",")[[1]])
  if (any(!(identifier %in% 1:length(module)))) stop("This choice (",identifier,") is not possible. Please type in a number between 1 and ",length(module))
  return(module[identifier])
}

choose_mode <- function(title="Please choose the output mode") {
  modes <- c("Output for single run ","Comparison across runs")
  cat("\n\n",title,":\n\n")
  cat(paste(1:length(modes), modes, sep=": " ),sep="\n")
  cat("\nNumber: ")
  identifier <- get_line()
  identifier <- as.numeric(strsplit(identifier,",")[[1]])
  if (identifier==1) {
    comp<-FALSE
  } else if (identifier==2) {
    comp<-TRUE
  } else {
    stop("This mode is invalid. Please choose a valid mode")
  }  
  return(comp)
}

if(exists("source_include")) {
  comp <- FALSE
} else {
  if(!exists("comp")) {
    comp<-choose_mode("Please choose the output mode")
  }
}


if (comp==TRUE) {
  print("comparsion")
  # Select output modules if not defined by readArgs
  if(!exists("output")) {
    output <- choose_module("./scripts/output/comparison","Please choose the output module to be used for output generation")
  }
  # Select output directories if not defined by readArgs
  if (!exists("outputdir")) {
    if (!exists("remind_dir")) {
      temp <- choose_folder("./output","Please choose the runs to be used for output generation")
      outputdirs <- temp
      for (i in 1:length(temp)) outputdirs[i] <- path("output",temp[i])
    } else {
      temp <- choose_folder(remind_dir,"Please choose the runs to be used for output generation")
      outputdirs <- temp
      for (i in 1:length(temp)) {
        last_iteration <- max(as.numeric(sub("magpie_","",grep("magpie_",base::list.dirs(path(remind_dir,temp[i],"data/results"),full.names = FALSE, recursive = FALSE),value=T))))
        outputdirs[i] <- path(remind_dir,temp[i],"data/results/",paste("magpie_",last_iteration,sep=""))
      }
    }
  } else outputdirs <- outputdir
  
  #Set value source_include so that loaded scripts know, that they are 
  #included as source (instead of a load from command line)
  source_include <- TRUE
  
  # Execute output scripts over all choosen folders
  for(rout in output){
    name<-paste(rout,".R",sep="")
    if(file.exists(paste("scripts/output/comparison/",name,sep=""))){
      print(paste("Executing",name))
      tmp.env <- new.env()
      if(debug) {
        sys.source(paste("scripts/output/comparison/",name,sep=""),envir=tmp.env)
      } else {
        tmp.error <- try(sys.source(paste("scripts/output/comparison/",name,sep=""),envir=tmp.env))
        if(!is.null(tmp.error)) warning("Script ",name," was stopped by an error and not executed properly!")        
      }
      rm(tmp.env)
      gc()
    } 
  }
  
  } else {
  
  # Select an output directory if not defined by readArgs
  if(!exists("outputdir")) {
    if (!exists("remind_dir")) {
      temp <- choose_folder("./output","Please choose the run(s) to be used for output generation")
      outputdirs <- temp
      for (i in 1:length(temp)) outputdirs[i] <- path("output",temp[i])
    } else {
      temp <- choose_folder(remind_dir,"Please choose the runs to be used for output generation")
      outputdirs <- temp
      for (i in 1:length(temp)) {
        last_iteration <- max(as.numeric(sub("magpie_","",grep("magpie_",base::list.dirs(path(remind_dir,temp[i],"data/results"),full.names = FALSE, recursive = FALSE),value=T))))
        outputdirs[i] <- path(remind_dir,temp[i],"data/results/",paste("magpie_",last_iteration,sep=""))
      }
    } 
  } else outputdirs <- outputdir
  
  #Execute outputscripts for all choosen folders
  for (outputdir in outputdirs) {
    
    # Select an output module if not defined by readArgs
    if(!exists("output")) {
      output <- choose_module("./scripts/output/single","Please choose the output module to be used for output generation")
    }
    
    if(exists("cfg")) {
      title    <- cfg$title
      gms      <- cfg$gms
      input    <- cfg$input
      revision <- cfg$revision
      magpie_folder <- cfg$magpie_folder
    }
    
    # Get values of config if output.R is called standalone
    if(!exists("source_include")) {
      magpie_folder <- getwd()
      if(file.exists(path(outputdir,"config.Rdata"))) {
        load(path(outputdir,"config.Rdata"))
        title    <- cfg$title
        gms      <- cfg$gms
        input    <- cfg$input
        revision <- cfg$revision
      } else {
        config <- grep("\\.cfg$",list.files(outputdir), value=TRUE)
        l<-readLines(path(outputdir,config))
        title <- strsplit(grep("(cfg\\$|)title +<-",l,value=TRUE),"\"")[[1]][2]
        gms <- list()
        gms$scenarios <- strsplit(grep("(cfg\\$|)gms\\$scenarios +<-",l,value=TRUE),"\"")[[1]][2]
        input <- strsplit(grep("(cfg\\$|)input +<-",l,value=TRUE),"\"")[[1]][2]
        revision <- as.numeric(unlist(strsplit(grep("(cfg\\$|)revision +<-",l,value=TRUE),"<-[ \t]*"))[2])
      }
    }
    
    #Set value source_include so that loaded scripts know, that they are 
    #included as source (instead of a load from command line)
    source_include <- TRUE
    
    # Get low_res and high_res from info.txt
    info.txt <- readLines(path(outputdir,"info.txt"),warn=FALSE)
    
    get_res <- function(file,pattern,sep) {
      res <- grep(pattern,file, value=TRUE)
      res <- strsplit(res, sep)
      res <- sapply(res, "[[", 2)
      if (!regexpr("[a-z]",res) > 0) {
        res <- as.numeric(res)
      }
      return(res)
    }
    low_res <- get_res(info.txt,"^Low resolution",": ")
    high_res <- get_res(info.txt,"^High resolution",": ")
    
    if (file.exists(path(outputdir,"output.RData"))) {
      data_workspace<-path(outputdir,"output.RData")
    } else {
      tmp<-strsplit(outputdir,"/")[[1]]
      data_workspace<-paste(outputdir,"/",tmp[length(tmp)],".RData",sep="")
    }
    
    sum_spam_file <- paste("",high_res,"-to-",low_res,"_sum.spam", sep="")
    
    cat(paste("\nStarting output generation for",outputdir,"\n\n"))
    
    ###################################################################################
    # Execute R scripts
    ###################################################################################
    
    for(rout in output){
      name<-paste(rout,".R",sep="")
      if(file.exists(paste("scripts/output/single/",name,sep=""))){
        cat("Executing",name,"...\n")
        tmp.env <- new.env()
        if(debug) {
          sys.source(paste("scripts/output/single/",name,sep=""),envir=tmp.env)         
        } else {
          tmp.error <- try(sys.source(paste("scripts/output/single/",name,sep=""),envir=tmp.env))
          if(!is.null(tmp.error)) {
            warning("Script ",name," was stopped by an error and not executed properly!")          
            cat("...",name,"failed!\n")
          } else {
            cat("...",name,"finished successfully!\n")
          }
        }
        rm(tmp.env)
        gc()
      }
    }
    # finished
    cat(paste("\nFinished output generation for",outputdir,"!\n\n"))
    rm(source_include)
    print(warnings())
  }
}
